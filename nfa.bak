#lang racket

(load "table.rkt")

(define (make-nfa Q Σ Δ q0 F)
  ; Q -> set of states
  ; Σ -> set of input symbols
  ; Δ -> a translation relation Q × Σ → P(Q)
  ; q0 -> an initial state
  ; F -> set of acceptable states
  ; TODO: ε-transfer
  (define (next-states q sym)
    ((Δ 'lookup) q sym))
  (define (accept? states)
    (if (null? (filter (lambda (s) (member s F)) states)) 
        #f
        #t))
  (define (recognize-iter curr-states str)
    (if (= (string-length str) 0)
        (accept? curr-states)
        (let ((first-sym (string-ref str 0))
              (rest-sym (substring str 1)))
          (for/or ([s curr-states])
            (recognize-iter (next-states s first-sym) rest-sym)))))
  (define (recognize str)
    (if (recognize-iter (list q0) str)
        'accept
        'reject))
  recognize)
