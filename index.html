<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="O-lex : A Original LEXical parser, written by Scheme/Racket" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>O-lex</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/silverbullettt/o-lex">View on GitHub</a>

          <h1 id="project_title">O-lex</h1>
          <h2 id="project_tagline">A original and lexical parser, written by Scheme/Racket</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/silverbullettt/o-lex/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/silverbullettt/o-lex/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>O-lex</h1>

<h2><strong>O-lex是什么？</strong></h2>

<p>o-lex (<strong>O</strong>riginal <strong>LEX</strong>xical parser)是一个由<a href="http://racket-lang.org/" title="DrRacket">DrRacket</a>编写，可用正则表达式描述词法规则的词法分析器。目前仅支持的一些基本的正则表达式模式，但足以描述词法规则。</p>

<h2><strong>正则表达式语法</strong></h2>

<h4><strong>转义字符</strong></h4>

<ul>
<li>
<strong>~</strong>： 将下一个字符标记为一个特殊字符、或一个原义字符<br>
</li>
</ul><h4><strong>通配符</strong></h4>

<ul>
<li>
<strong>~d</strong>：匹配一个数字字符</li>
<li>
<strong>~c</strong>：匹配一个英文字符</li>
<li>
<strong>[xyz]</strong>：字符集合，匹配括号中包含的任何一个字符，括号中的字符不需要转义</li>
<li>
<strong>[^xyz]</strong>：反字符集合，匹配不在括号中的任何一个字符，括号中的字符同样不需要转义</li>
</ul><h4><strong>或</strong></h4>

<ul>
<li>
<strong>|</strong>：表示多个模式中任意匹配一个，如“wh(at|ere)”，可匹配“what”或“where”</li>
</ul><h4><strong>数量限定</strong></h4>

<ul>
<li>
<strong>+</strong>：表示前面的字符（或模式）可出现一次或多次，如“Micro+soft”可匹配“Microsoft”和“Microoooosoft”</li>
<li>
<strong>*</strong>：表示前面的字符（或模式）可出现零次或多次，如“~c*”可匹配空串和任意英文单词</li>
<li>
<strong>?</strong>：表现前面的字符（或模式）可出现零次或一次，如“(+|-)?~d+”可表示任意有符号整数和无符号整数</li>
</ul><h4><strong>特殊字符</strong></h4>

<ul>
<li>当‘~’、‘|’、‘[’、‘(’、‘+’、‘*’、‘?’这几个字符作为普通字符出现时，均要在前面加上转义字符‘~’</li>
</ul><h2><strong>如何使用o-lex</strong></h2>

<p>非常简单。  </p>

<p><code>(make-lex-parser regex-list [cmt-tag] [str-tag])</code>，<a href="https://github.com/silverbullettt/o-lex/blob/master/lex-parser.rkt" title="lex-parser.rkt">lex-parser.rkt</a></p>

<ul>
<li>regex-list：表示词法规则的正则表达式以及对应token-type的列表</li>
<li>cmt-tag：表示注释的符号，调用<code>make-lex-parser</code>时带上这个参数，则parser返回的单词流中不包含注释</li>
<li>str-tag：表示字符串的符号，调用<code>make-lex-parser</code>时带上这个参数，则parser会去掉字符串开头和结尾的引号（否则单词的开头和结尾各有2个引号）</li>
</ul><p><code>make-lex-parser</code>接受词法规则，返回一个词法解析器，该解析器接受字符串，返回单词流。返回参数中包含单词类型、单词本身、所在行号以及在该行的偏移。</p>

<p><code>(make-regex-recognizer regex)</code>，<a href="https://github.com/silverbullettt/o-lex/blob/master/regex-parser.rkt" title="regex-parser.rkt">regex-parser.rkt</a><br><code>(make-regex-matcher regex)</code>，<a href="https://github.com/silverbullettt/o-lex/blob/master/regex-parser.rkt" title="regex-parser.rkt">regex-parser.rkt</a></p>

<p>作为用正则表达式表示词法规则的副产品，o-lex还包含一个正则表达式的识别器和匹配器。前者可识别一个字符串是否符合给定的表达式；后者从一个字符串中找出符合表达式的所有串，并给出它们的起始位置。</p>

<h2><strong>示例</strong></h2>

<ol>
<li>
<p>用<code>make-regex-recognizer</code>构造一个能识别一个字符串是否符合yyyy-MM-dd格式日期识别器
</p>
<pre><code>
&gt; (<strong>define</strong> data (make-regex-recognizer "~d~d~d~d-[01]~d-[0123]~d"))
&gt; (data "2012-08-18")
'accept
&gt; (data "2012.12.21")
'reject
</code></pre>
</li>
<li>
<p>用<code>make-regex-matcher</code>提取出字符串中的数字
</p>
<pre><code>
&gt;(<strong>define</strong> num (make-regex-matcher "(~+|-)?~d+(.~d+)?(e(~+|-)?~d+(.~d+)?)?"))
&gt; (num "I'm 21 years old, I have $-123.45, Avogadro's constant equals 6.02e23.")
'(("21" . 4) ("-123.45" . 26) ("6.02e23" . 62))
</code></pre>
</li>
<li>
<p>用<code>make-lex-parser</code>构造词法分析器，并识别出代码中的词素
</p>
<pre><code>
&gt;(<strong>define</strong> lp (make-lex-parser '(("(_|~c)(_|~c|~d)*" id)
                               ("~d+" num)
                               ("\"[^\"]*\"" string)
                               ("~+" plus)
                               ("=" assign)
                               ("~(" lbrac)
                               (")" rbrac)
                               (";" semi)
                               ("output" output))))
&gt;(lp (lp "x = 123+456;\noutput(x);")
'((id "x" 1 1)
  (assign "=" 1 3)
  (num "123" 1 5)
  (plus "+" 1 8)
  (num "456" 1 9)
  (semi ";" 1 12)
  (output "output" 2 1)
  (lbrac "(" 2 7)
  (id "x" 2 8)
  (rbrac ")" 2 9)
  (semi ";" 2 10))
</code></pre>
</li>
</ol><h2><strong>碎碎念</strong></h2>

<p>你可以很明显的看到，o-lex有一些奇怪的地方，这完全是我的个人原因。比如为什么用‘~’而不用‘\’做转义字符呢，因为在 <em>Scheme</em> 里‘\’也是转义字符，这意味着如果我也用‘\’做转义字符，那么在正则表达式里像匹配一个普通的‘\’就得输入四个‘\’(比如<code>(define slash (make-regex-recognizer "\\\\")</code>），这太蛋疼了，所以我决定用‘~’，因为 <em>Scheme</em> 的<code>printf</code>中也用‘~’。</p>

<p>另外通配符也很少，没有‘.’，但你知道怎么写出匹配所有字符的表达式吗？没错，“[^]”就可以了……o-lex是词法分析器，支持正则表达式只是为了方便定义词法规则，编程语言的词法规则都很简单，所有很多功能我就懒得实现了- - o-lex对付源文件基本上完全够用了。</p>

<p>哦还有一个问题，<code>make-lex-parser</code> 的第一个参数是个列表，在这个列表中越靠后的词法规则优先级越高，所以关键字都必须放在id这种通配符规则的后面。这个bug影响不大，我也懒得解决了。</p>

<p>最后一个问题，不要跨行。有两种词素是可能跨行的，<em>块注释</em> 和 <em>字符串</em> ，o-lex还搞不定这两种词素，它们如果出现会导致后序词素行号出错。所以使用o-lex的时候就不要定义块注释，也不要整跨行字符串。目前o-lex不支持从文件中读入，不过这个问题很快就会解决……</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">O-lex maintained by <a href="https://github.com/silverbullettt">silverbullettt</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
